# 大作业报告

## 实现思路

通过阅读已给代码框架，可以发现本次作业主要要实现的是`Verifier.cs`中的`Apply`函数。该函数接收cfg为参数，返回1或-1指示验证成功与否。

根据课上讲述内容，要验证一个过程是否具备正确（包括部分正确和完全正确），就要验证每条基本路径都是正确的。验证基本路径的正确性，就要从后往前计算最弱前置条件wp，并证明前置条件φ可以推出wp。对于需要验证完全正确性的过程，还需根据秩函数判断其终止性。



## 实现过程

+ 首先将cfg的所有谓词加入SMT，以供后续直接利用SMT验证逻辑公式的有效性。

+ 然后对cfg中的所有函数生成基本路径，这里使用了BFS的搜索方法，递归调用自定义函数`Generate_basic_path`，针对不同的`Location`，采取不同的处理方法。

+ 获取所有的基本路径后，对每一条基本路径，都生成其验证条件，并投入SMT中进行验证。验证条件的计算利用自定义函数`Cal_verification_condition`，该函数接受一条基本路径，从后往前依次计算，最后利用`ImplicationExpression`合并成$\phi ==> \phi^{'}$的形式返回供SMT使用。
+ 最后是终止性的计算。调用自定义函数`Verify_rank`，先用获取基本路径上开始的地方(循环头或者函数调用语句)。之后，从此处用 计算秩函数是否递减。再继续计算该基本路径上是否有更多的函数调用。每次从该处开始，再计算秩函数是否递减。其中，对于前后两个秩函数，要将第一个秩函数进行替换，替换后构造出秩函数递减语句。随后计算最弱前置条件，最后将变量替换回来。



## 遇到问题及感想

+ C#不熟悉，用=直接进行类变量赋值时产生了许多问题。
+ 没有仔细阅读全部代码框架，一开始妄图自己实现一个`Basicpath`，且没注意SMT可自行计算有效性，导致走了些许弯路。
+ 计算基本路径和终止性的验证部分还是十分复杂的，有时候过了前几个样例以为没问题，实际上对于复杂样例还是考虑不够周全。

+ 实现程序验证的思路想起来很简单，但真正实现起来会发现大量问题。这指示了动手实践的重要性。